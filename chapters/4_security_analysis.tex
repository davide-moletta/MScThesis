\chapter{Threat Analysis}
\label{cha:ta}

This chapter focusses on exploring the potential security vulnerabilities that
\textit{STEERED} aims to mitigate, alongside the methodologies used to evaluate
the threat resilience of the project. Additionally, we discuss the limitations
of the system, providing an accurate portrayal of its practical scope and constraints.
Lastly, we showcase how the project may be improved from a security perspective.

\section{Threat Model}
\label{sec:ta_model}

\textit{STEERED} is primarily focused on addressing attacks that aim at exploiting
vulnerabilities to alter the intended execution path of programs. The most
critical threats include:
\begin{itemize}
  \item Return-Oriented Programming (ROP): An attacker can manipulate the call
    stack to execute arbitrary sequences of instructions by chaining snippets of
    existing code (gadgets) ending in return instructions. In this case, \textit{STEERED}
    would detect the call to the first gadget as it would not be part of the Control
    Flow Graph. Even in the case that the jump is considered legal, the first gadget
    that attempts to return would fail due to Shadow Stack matching. In the
    latter, the first gadget would execute but this is not a problem since usually
    one gadget is not enough to perpetrate an attack;

  \item Jump-Oriented Programming (JOP): Works similarly to ROP but focuses on
    exploiting indirect jumps to hijack control flow instead of return
    instructions. As already explained for Return-Oriented Programming, \textit{STEERED}
    would either detect the first illegal jump instruction or the first return instruction,
    preventing exploitation;

  \item Call-Oriented Programming (COP): A variant of JOP where the attacker
    abuses call instructions (direct jump) to hijack control flow. The outcome is
    the same as Jump-Oriented Programming as we provide security for both indirect
    jump instructions and call instructions;

  \item Code Injection: Instead of relying on existing code, the attacker injects
    and executes its own malicious code, exploiting a program vulnerability. While
    these attacks may be harder to perform, they pose a bigger threat as the
    capability of the attacker is not limited to the pre-existing code. While \textit{STEERED}
    itself doesn't directly prevent code injection, its requirement for valid control
    flow ensures that injected code cannot execute unless it conforms to the program's
    Control Flow Graph;

  \item Buffer Overflows: A common precursor to control-flow attacks, allowing attackers
    to overwrite critical control structures, such as return addresses to tamper
    with the control flow of the code. In this case \textit{STEERED} would
    simply identify the modified return address as soon as a function attempts
    to return making exploitation through buffer overflows impossible.
\end{itemize}

The project assumes an attacker can inject or modify code within user-mode
applications on a RISC-V processor but cannot alter the control flow enforcer
itself or modify privileged memory regions without triggering traps. Moreover,
the threat model assumes that the attacker has no direct physical access to the
device but can exploit software vulnerabilities via malicious input.

Lastly, the model does not account for hardware-specific attacks like side-channel
attacks or physical tampering as well as \textit{RISC-V}-related vulnerabilities
that may allow to bypass \textit{STEERED}'s security features.

\section{Testing Methodologies}
\label{sec:ta_methodologies}

The evaluation of \textit{STEERED}'s security has been conducted with both static
and dynamic analysis techniques, tailored to assess the system's resilience to
the identified threats. Moreover, we provided additional analysis specifically
designed to establish the correctness of the Control Flow Graph, Shadow Stack,
and the Physical Memory Protection. \textit{STEERED}'s testing has been
conducted as follows:

\begin{itemize}
  \item Static Analysis: during this step, we analyzed the source code of \textit{STEERED},
    identifying eventual flaws or implementation errors. Furthermore, we identified
    the expected scenarios during execution. This led to the actual
    implementation of the project where all the ``standard'' routes have been
    manually vetted to determine their correctness;

  \item Control Flow Graph Validation: in this phase we extracted the CFG and
    validated it against predefined legitimate execution paths. Any deviation observed
    during testing was flagged as a potential vulnerability. This led us to
    define a Control Flow Graph extraction function that is reliable and
    provides an accurate representation of the CFG;

  \item Shadow Stack Validation: in this step we validated the functions used to
    interact with the Shadow Stack. We ensured that addresses are stored correctly
    and that the popping and matching logic was applied securely to provide reliable
    information about return instruction legality;

  \item Physical Memory Protection Validation: we conducted some tests to check
    the Physical Memory Protection configuration. Such tests involved trying to access
    secure parts of the memory from the user code. As a result, we determined that
    each access both in read and write mode resulted in the generation of a trap
    that was then handled by the interrupt vector table. This testing validated
    that PMP effectively restricts access, protecting the integrity of the Shadow
    Stack and Control Flow Graph from unauthorized modifications;

  \item Dynamic Analysis: we performed dynamic testing of edge controls to test
    their secureness. The system was subjected to simulations using a variety of
    inputs designed to trigger control-flow vulnerabilities, such as crafted
    payloads that mimic ROP and JOP attacks. . With such instructions, we tried
    to perform unauthorized control transfers and, in all cases the Control Flow
    Integrity Enforcer was able to detect the instruction and prevent the control
    transfer. Moreover, logging mechanisms were implemented during testing to capture
    runtime behavior, enabling the detection of any deviation from the expected
    control flow;

  \item Edge Case Validation: lastly, we performed tests on edge cases. These
    tests were conducted to verify system behavior under peculiar circumstances
    such as an empty or full Shadow Stack.
\end{itemize}

Overall, we cna see that \textit{STEERED} has been tested against various attack
scenarios and unexpected cases. Test results show that the system is capable of
managing such situations and can be trusted to ensure that the control flow
integrity of the code is preserved.

\section{Limitations}
\label{sec:ta_limitations}

While the project demonstrates substantial threat resilience, certain
limitations remain.

As we will see in the next chapter, the Shadow Stack requirements for deeply recursive
functions present a scalability issue, especially in memory-constrained
environments. Recursive functions with large call depths may cause the Shadow Stack
to overflow, which could halt execution prematurely. Even if this does not affect
security it could prevent the utilization of the project in microcontrollers with
very small memory capabilities.

Moreover, as this threat model does not address hardware-level attacks, it does not
cover scenarios where attackers may physically tamper with the microcontroller.
To protect against such attacks, additional hardware-based security mechanisms would
be necessary.

Furthermore, there could be edge cases that have not been discovered which could
lead to potential exploitations of the code. However, these can be discovered
through exhaustive testing and will be part of future development.

Lastly, we can't know if vulnerabilities related to the \textit{RISC-V}
Instruction Set Architecture could lead to the exploitation of the user code. In
such case, we can't be sure that the project will be able to protect the Control
Flow Integrity and prevent exploitation. For example, the recently discovered
hardware vulnerability in \textit{T-Head's XuanTie C910 and C920} CPUs named ``\textit{GhostWrite}''
\cite{riscvuzz} allow an attacker with limited privileges to read and write from
and to physical memory. This type of vulnerability could not be prevented with the
project's security features.

In summary, the project provides robust protection against unauthorized control
transfers in \textit{RISC-V} microcontrollers, particularly effective in
embedded environments where code integrity is paramount. While the model is limited
in handling recursion-heavy applications and relies on PMP for data protection,
it nonetheless establishes a secure foundation for CFI, with the potential for further
optimization in future iterations. Moreover, \textit{project name} could be
implemented together with other security mechanisms to completely secure an
embedded device.
